data â† â€¢file.Lines "../../samples/2020/day7.txt"
data â†© â€¢file.Lines "../../samples/2020/day7_alt.txt"
data â†© â€¢file.Lines "../../inputs/2020/day7.txt"

Log â† {
	msgâ€¿val â† ğ•©
	â€¢Show msgâ€¿val
	val
}


SplitBy â† (+`âˆ˜=âŠ”âŠ¢)

# from bqncrate
FindInString â† {âˆŠâŸœğ•©âŒ¾<ğ•¨}

# remove substring from string
StripSubstring â† {
	full_find â† ğ•¨(â‰¢âˆ˜âŠ¢â†‘â·)ğ•©
	sub_range â† â†•â‰ ğ•¨
	full_range â† â†•â‰ ğ•©

	# characters not in the substring
	mask â† full_range Â¬âˆ˜âˆŠâ¥Š (sub_rangeâŠ¸+)Ë˜ full_find/full_range
	mask/ğ•©
}

# find which character is a digit character
IsNonNumericChar â† {
	nums â† '0'+â†•10
	res â† >Â¬âŒˆË nums= ğ•©
}
# â€¢Show IsNonNumericChar <"99i 2 am 55 years old"

MarkAllowed â† {
	full_find â† ğ•¨(â‰¢âˆ˜âŠ¢â†‘â·)ğ•©
	sub_range â† â†•â‰ ğ•¨
	full_range â† â†•â‰ ğ•©

	# characters not in the substring
	mask â† full_range Â¬âˆ˜âˆŠâ¥Š (sub_rangeâŠ¸+)Ë˜ full_find/full_range
}


ParseAllNumbers â† {
	# 1s where a digit is found
	mask â† (Â¬IsNonNumericChar < ğ•©)
	# start index and end index of each number within the string
	bounds â† âˆ˜â€¿2â¥Š/0 (âˆ¾â‰ âˆ¾Ëœ) mask
	# the start index plus its offset
	join â† (âŠâˆ¾-ËœÂ´)Ë˜bounds
	# each index in the string a digit is at
	idxs â† (<â†•âˆ˜(1âŠ¸âŠ‘)+Ë˜âŠ‘)Ë˜join
	# pull out each char at each index, and parse the whole number
	parsed â†(â€¢ParseFloat âŠâŸœğ•© )Â¨idxs
	parsed
}

ParseBagNew â† {
	# mostly from bqnrate, splits on mask ğ•¨
	Gather â† +`(Ã—âŠâ€¢Show)Â¬
	Split â† ((0âŠ¸â‰ âˆ˜â‰ Â¨)/âŠ¢)((âŠ¢-ËœGather)âŠ¸âŠ”)

	# run many precleaners on the input
	preclean â† ğ•© StripSubstringÂ´ âŸ¨".", " bag", " bags"âŸ©

	mask â† Â¬" contain " MarkAllowed preclean
	containerâ€¿raw_childrenâ† (mask) Split preclean

	comma_mask â† Â¬ "," MarkAllowed raw_children
	# â€¢Show comma_mask

	DropLeadingSpace â† ((' '=âŠ)â†“âŠ¢)
	JoinFunc â† ParseAllNumbersâˆ¾(<âˆ˜DropLeadingSpace IsNonNumericCharâˆ˜</âŠ¢)
	children â† (JoinFunc DropLeadingSpace)Â¨ comma_mask Split raw_children
	containerâ€¿children
}


# which bags can eventually contain a shiny gold bag?
BreakIntoParentChildPairs â† {
	bags â† ParseBagNewÂ¨ ğ•©

	ConcatChildren â† {
		containerâ€¿children â† ğ•©
		((<container)âŠ¸âˆ¾âˆ˜<)Â¨ children

	}
	parent_child_pairs â† âˆ¾â¥ŠË˜ (>ConcatChildren)Â¨ bags
	parent_child_pairs
}

Sep â† {
	num â† 10
	ğ•©
	â€¢Out  âˆ¾Â´ â¥Š âˆ¾Â´ ((num/"-")â€¿(â€¢Repr ğ•©)â€¿(num/"-"))
}

PartOne â† {
	parent_child_pairs â† BreakIntoParentChildPairs ğ•©

	all_found_bags â† âŸ¨âŸ©

	containing_target â† âŸ¨âŸ©

	FindBags â† {

		target â† ğ•©

		bags_containing_target_mask â† (targetâŠ¸âˆŠ1âŠ¸âŠ‘)Ë˜ parent_child_pairs

		containing_target â†© âŠË˜ bags_containing_target_mask/parent_child_pairs

		found_new_containers â† (0â‰ â‰  containing_target)
		{ found_new_containers ?
			{ all_found_bags â†© â·all_found_bags âˆ¾ containing_target}
			; 0
		}
		containing_target
	}
	new_bags â† âŸ¨"shiny gold", "shiny gold"âŸ©

	Massage â† {
		found â†  FindBags ğ•©
		found
	}

	Body â† {
		raw_new_bags â† ((<âˆ˜Massage)Ë˜) ğ•©

		new_bags â†© â·âˆ˜({ "shape"â€¿(â‰¢ğ•©)}âŠ¢âŠ¢) (âˆ¾â¥Š) raw_new_bags

		new_bags
	}

	Condition â† {
		ğ•©
		# â€¢Show "loop check"
		res â† 0â‰ â‰  new_bags
		res
	}
	Body â€¢_while_ Condition new_bags

	all_found_bags
	â€¢Show â‰ all_found_bags

}

Gather â† {âˆ§((âŠâŠ)âˆ¾(+Â´1âŠâ‰))Â¨ ((âŠâŠË˜)âŠ”âŠ¢) ğ•©}
null â† @+0

PartTwo â† {
	parent_child_pairs â† BreakIntoParentChildPairs ğ•©
	parent_scores â† (nullâˆ¾Ëœ 0âŠ¸âŠ)Ë˜ parent_child_pairs

	# normalize the no other bags to 0 value
	NormalizeNoOther â† {
		bag_nameâ€¿Â· â† ğ•©
		((â‹ˆ"no other")â‰¡(1âŠ‘ğ•©))
		? âŸ¨bag_name, 0â‹ˆ"no other"âŸ©
		; ğ•©
	}
	parent_child_pairs â†© NormalizeNoOtherË˜ parent_child_pairs
	â€¢Show parent_child_pairs


	total_contained â† 0


	targets â† âŸ¨"shiny gold"âŸ©
	# â€¢Show (âŠâŸœtargetsâŠ¸âŠ)Ë â‰parent_child_pairs

	â€¢Show âˆ˜â€¿1â¥Š(1âŠâ‰parent_child_pairs) âŠËœ(âŠ¢/â†•âˆ˜â‰ )(âŠâ‰parent_child_pairs)âˆŠ targets
	vowels â† "aeiou"

	# RemVow â† ((Â¬ vowelsâŠ¸(âˆŠËœ))/âŠ¢)
  #
	# Shorten â† {ğ•Šword:
	# 	â€¢Show word
	# 	â·((32âŠ¸(-Ëœ)âŠ)âˆ¾((1âŠ¸âŠâˆ¾Â¯1âŠ¸âŠ)âˆ˜RemVow))word
	# }
	# â€¢Show â†‘â€¿1â¥Š((Shorten(' 'âŠ¸â‰ )/âŠ¢)Â¨ ((+` ' 'âŠ¸=)âŠ”âŠ¢))Â¨â·âŠË˜ parent_child_pairs


	old_targets â† âŸ¨âŸ©
	total_children â† 1
	Iter â† {ğ•Štarget :
		old_targets â†© old_targetsâˆ¾(<target)
		matches â† (((/(targetâŠ¸â‰¡)Â¨)Â·âŠâ‰)(â¥Š1âŠÂ·â‰âŠ)âŠ¢) parent_child_pairs
		total_children â†© total_children + (â‰ matches)
		matches
	}
	SplitIter â† {
		countâ€¿bagâ† ğ•©
		â¥Š count/(â‹ˆbag)
	}

	targets â†© {
		âˆ¾ â¥Š SplitIterÂ¨ Â· âˆ¾Â´ IterÂ¨ ğ•©}â€¢_while_(0â‰ â‰ ) targets

	# â€¢Show old_targets
	â€¢Show "solution:"â€¿(1-Ëœ â‰ old_targets)


}

# PartOne data
PartTwo data
