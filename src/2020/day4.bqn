data â† â€¢file.Lines "../../samples/2020/day4.txt"
# data â† â€¢file.Lines "../../inputs/2020/day4.txt"

# numbers â† â€¢ParseFloatÂ¨ data

# byr (Birth Year)
# iyr (Issue Year)
# eyr (Expiration Year)
# hgt (Height)
# hcl (Hair Color)
# ecl (Eye Color)
# pid (Passport ID)
# cid (Country ID)

field_names â† âŸ¨"byr", "iyr", "eyr", "hgt", "hcl", "ecl", "pid", "cid"âŸ©
fields_no_cid â† ((Â¬"cid"âŠ¸â‰¡)Â¨/âŠ¢)field_names

SplitBy â† (+`âˆ˜=âŠ”âŠ¢)
# â€¢Show ' 'SplitBy "a b c   d"



RemoveSpaceOnlyLists â† (âˆ¨`' 'âŠ¸â‰ )âŠ¸/
RemoveSpaces â† (' 'âŠ¸â‰ )âŠ¸/

# takes a list of strings and returns a single group of strings without spaces
GatherPassports â† {
	JoinWithSpace â† {ğ•¨âˆ¾ " "âˆ¾ğ•©}Â´
	Foo â† RemoveSpaceOnlyLists JoinWithSpace
	RemoveSpacesÂ¨ ' 'SplitBy Foo ğ•©
}


# â€¢Show  âŠ£ËœâŠ¸/Â¨ 1/Â¨ 0 SplitBy Â¬0=â‰ Â¨ data

ParseNum â† â€¢ParseFloatâŠ(-2Ë™)

#BYR
IsValidByrNum â† 1920âŠ¸â‰¤âˆ§â‰¤âŸœ2002
IsValidByr â† {
	correct_len â† 4=â‰ ğ•©
	correct_len âˆ§ IsValidByrNum ParseNum ğ•©
}

#IYR
IsValidIyrNum â† 2010âŠ¸â‰¤âˆ§â‰¤âŸœ2020
IsValidIyr â† {
	correct_len â† 4=â‰ ğ•©
	correct_len âˆ§ IsValidIyrNum ParseNum ğ•©
}

#EYR
IsValidEyrNum â† 2020âŠ¸â‰¤âˆ§â‰¤âŸœ2030
IsValidEyr â† {
	correct_len â† 4=â‰ ğ•©
	correct_len âˆ§ IsValidEyrNum ParseNum ğ•©
}

# keep only digits, anywhere in the string
# "a1b2c3" -> "123"
KeepDigits â† âˆŠâŸœ('0'+â†•10)âŠ¸/

#HGT
IsValidHgtInches â† 59âŠ¸â‰¤âˆ§â‰¤âŸœ76
IsValidHgtCm â† 150âŠ¸â‰¤âˆ§â‰¤âŸœ193
IsValidHgt â† {
	contains_inches â† âˆ¨Â´(â‰ "in")â‰ "in"âŠğ•©
	contains_cm â† âˆ¨Â´(â‰ "cm")â‰ "cm"âŠğ•©
	digits â† KeepDigits ğ•©
	# â€¢Show "ASD"â€¿contains_cmâ€¿contains_inchesâ€¿(contains_inches âˆ§ (IsValidHgtInches ğ•©))
	{
	contains_inches ? IsValidHgtInches â€¢ParseFloat KeepDigits ğ•©;
	contains_cm ? IsValidHgtCm â€¢ParseFloat KeepDigits ğ•©;
		0
	}ğ•©
}

hgt_asserts â† {
	"expected HGT 58in is false"  !Â¬ IsValidHgt "58in"
	"expected HGT 59in is valid"  !  IsValidHgt "59in"
	"expected HGT 76in is valid"  !  IsValidHgt "76in"
	"expected HGT 77in is false"  !Â¬ IsValidHgt "77in"

	"expected HGT 149cm is false" !Â¬ IsValidHgt "149cm"
	"expected HGT 150cm is valid" !  IsValidHgt "150cm"
	"expected HGT 193cm is valid" !  IsValidHgt "193cm"
	"expected HGT 194cm is valid" !Â¬ IsValidHgt "194cm"
}

IsAllowedHclChars â† âˆ§Â´âˆŠâŸœ(âˆ¾"0a"+âŸœâ†•Â¨10â€¿6)
IsValidHcl â† {

 starts_with_hash â† {0â‰ â‰ ğ•© ? '#'=âŠ‘ğ•© ; 0}ğ•©
 "type"â€¿(â€¢Type starts_with_hash)

#  â€¢Show 50/"_"
 nonhash_chars â† (Â¬âˆŠ)âŸœ"#"âŠ¸/ğ•©
 is_length_correct â† 6=â‰ nonhash_chars
 only_valid_chars â† IsAllowedHclChars nonhash_chars
 starts_with_hash
#  â€¢Show 50/"-"

 is_length_correct âˆ§ only_valid_chars âˆ§ starts_with_hash
}

#HCL
hcl_asserts â† {
	"expected HCL #123abc  to be valid"          !  IsValidHcl "#123abc"
	"expected HCL #abc123  to be valid"          !  IsValidHcl "#abc123"
	"expected HCL #111111  to be valid"          !  IsValidHcl "#111111"
	"expected HCL #aaaaaa  to be valid"          !  IsValidHcl "#aaaaaa"
	"expected HCL #123abz  to be false (z char)" !Â¬ IsValidHcl "#123abz"
	"expected HCL 123abc   to be false (no hash)"!Â¬ IsValidHcl "123abc"
	"expected HCL #123ab   to be false (no char)"!Â¬ IsValidHcl "#123ab"
	"expected HCL #123abcd to be false (length)" !Â¬ IsValidHcl "#123abcd"
	"expected HCL #123abce to be false (length)" !Â¬ IsValidHcl "#123abce"
}


#ECL
eye_colors â† âŸ¨"amb", "blu", "brn", "gry", "grn", "hzl", "oth"âŸ©
IsValidEcl â† âˆŠâŸœeye_colorsâŒ¾<
ecl_asserts â† {
	"expected ECL amb  to be valid" !   IsValidEcl "amb"
	"expected ECL ambb to be valid" !Â¬  IsValidEcl "ambb"
	"expected ECL wat  to be false" !Â¬	IsValidEcl "wat"
	"expected ECL oth  to be valid" ! 	IsValidEcl "oth"
}

#PID
IsValidPid â† âˆ§Â´âˆŠâŸœ(âˆ¾"0"+âŸœâ†•Â¨10)âˆ§(9=â‰ )
# â€¢Show IsValidPid "123456789"
pid_asserts â† {
	"expected PID 000000001  to be valid" !  IsValidPid "000000001"
	"expected PID 0123456789 to be false" !Â¬ IsValidPid "0123456789"
	"expected PID 123456789  to be valid" !  IsValidPid "123456789"
	"expected PID 1234567890 to be false" !Â¬ IsValidPid "1234567890"
	"expected PID 000000000  to be valid" !  IsValidPid "000000000"
}

#CID
# ignored, missing or not

byr_asserts â† {
	"expected BYR 1919 is wrong" !Â¬ IsValidByr "1919"
	"expected BYR 1920 is valid" !  IsValidByr "1920"
	"expected BYR 1921 is valid" !  IsValidByr "1921"

	"expected BYR 2002 is valid" !  IsValidByr "2002"
	"expected BYR 2003 is wrong" !Â¬ IsValidByr "2003"
}

validators â† (0âŠ¸âŠË˜ â€¢Hashmap 1âŠ¸âŠË˜)[
	"byr"â€¿IsValidByr, "iyr"â€¿IsValidIyr, "eyr"â€¿IsValidEyr,
	"hgt"â€¿IsValidHgt, "hcl"â€¿IsValidHcl, "ecl"â€¿IsValidEcl,
	"pid"â€¿IsValidPid
]


Taker â† â¥Š{ ğ•¨âŠğ•© }Â¨
PerRawPassport â† {
	("takes lists of pairs"âŠ¸! 2âŠ¸â‰¡â‰¢>)Ë˜ ğ•©
	PerPair â† {
		keyâ€¿value â†  â¥Š ğ•©
		# â€¢Show keyâ€¿(':'âŠ¸â‰ âŠ¸/value)
		key
	}
	PerEntryGroup â† {
		PerPair ğ•©
	}
	rows â† â¥Šâš‡Â¯1ğ•©

	keys â† >(0âŠ¸Taker rows)
	sorted_keys â† âˆ¨ keys

	values â† (1âŠ¸Taker rows)
	mapped_passport â† (keys â€¢Hashmap values)

	FieldValid â† {
		field â† ğ•©
		# TODO: remove mapped_passport
		# dropping 1, because SplitBy leaves the split value in the non-first parts
		stripped_value â† 1â†“ mapped_passport.Get  field
		validator â† validators.Get field
		is_valid â† Validator stripped_value
		# â€¢Show fieldâ€¿stripped_valueâ€¿is_valid
	}


	has_enough_keys â† (âˆ¨fields_no_cid) â‰¡ ((Â¬"cid"âŠ¸â‰¡)Â¨/âŠ¢) sorted_keys

	{ has_enough_keys ?
		{ fields_valid â† âˆ§Â´ FieldValidÂ¨ fields_no_cid
		}
		; 0
	}

}

grouped_idxs â† 0 ((+`âˆ˜=){ ğ•¨âŠ”â†•â‰ ğ•© }âŠ¢) Â¬ 0= â‰ Â¨ data
grouped_data â† {ğ•©âŠdata}Ë˜Â¨ grouped_idxs
# â€¢Show (âŠgrouped_data)

raw_passports â† GatherPassportsÂ¨ grouped_data
# TODO: figure out the reason why they're all nested and we need to > them.
raw_parsed_passports â†  (( ':'âŠ¸SplitByÂ¨ ' 'âŠ¸SplitBy)Â¨)Â¨ raw_passports


# mapped_passport â†  (0âŠ¸Taker â€¢Hashmap (1âŠ¸Taker)) â¥Š âŠ‘raw_parsed_passports
# â€¢Show mapped_passport.Keys mapped_passport

â€¢Show (PerRawPassport>)Â¨ raw_parsed_passports

