data â† â€¢file.Lines "../../samples/2024/day11.txt"
# data â†© â€¢file.Lines "../../samples/2024/day11_alt.txt"
# data â†© â€¢file.Lines "../../inputs/2024/day11.txt"



# dyadic show but returns paired args
DShow â† {â€¢Show ğ•¨â€¿ğ•©â‹„ ğ•©}

Log â† {msgğ•Šval:
	â€¢Show (<msg)âˆ¾val
	val
}
RLog â† {msgğ•Šval:
	â€¢Show (msg)â‹ˆval
	val
}

# step, stone -> value
cache â† âŸ¨âŸ© â€¢Hashmap âŸ¨âŸ©
CacheIt â† {stepâ€¿stoneğ•Švalue:
	stepâ€¿stone cache.Set value
}

pows â† 10â‹† â€¢Show â†•16
evens â† 0âŒ¾âŠ‘ 0=2|â†•16
rests â† 0âŒ¾âŠ‘ Â¬evens
â€¢Show 10âŠ¸(â‹†â¼)500

â€¢ShowÂ¨ +Â´âˆ˜âŠ‘Â¨ { nsğ•Švs:
  lens â† powsâ‹vs
  rnâ€¿rv â† âˆ¾Â¨<Ë˜â‰>âŸ¨
    {nsâ†(lens=0)/ns â‹„ âŸ¨ns, 1Â¨nsâŸ©}
    {nsâ€¿vsâ€¿ls: âŸ¨nsâˆ¾ns, ((lsÃ·2)âŠpows) (| âˆ¾ âŒŠâˆ˜Ã·Ëœ) vsâŸ©} (lensâŠevens)âŠ¸/Â¨ nsâ€¿vsâ€¿lens
    2024âŠ¸Ã—âŒ¾(1âŠ¸âŠ‘) (lensâŠrests)âŠ¸/Â¨ nsâ€¿vs
  âŸ©
  g â† âŠ rv
  âŸ¨+Â´Â¨ g âŠ” rn, (âˆŠg)/rvâŸ©
}Â´âŸ(â‹ˆ25) 1Â¨âŠ¸â‹ˆ âŸ¨0, 27, 5409930, 828979, 4471, 3, 68524, 170âŸ©

â€¢Exit 0
iters â† âŸ¨âŸ©
PartOne â† {ğ•Šlines:
	Incr â† {ğ•©} #{ğ•Šstone: iters â†© itersâˆ¾stone}
	Next â† {
		0: Incr 0â‹„âŸ¨1âŸ©;
		ğ•Šstone: 0=2âŠ¸|â‰ â€¢Repr stone ?
			Incr stone
			len â† Ã·âŸœ2â‰   repr â† â€¢Repr  stone
			(â€¢ParseFloat lenâ†‘repr)â€¿(â€¢ParseFloat lenâ†“repr)
		;
		ğ•Šstone: Incr stoneâ‹„âŸ¨stone Ã— 2024âŸ©
	}

	stones â†  â€¢ParseFloatÂ¨ ((' 'âŠ¸â‰ ))âŠ¸/Â¨ (+`' 'âŠ¸=)âŠ¸âŠ” âŠ‘lines
	res â† â‰  (âˆ¾ NextÂ¨)âŸ25 stones
	"iters" Log (â‰ iters)â€¿(â‰ â·iters)

	res

}

PartTwoAlt â† {ğ•Šlines:
	memo â† âŸ¨0âŸ© â€¢Hashmap âŸ¨âŸ¨1âŸ©âŸ©

	Save â† {stoneğ•Šresulting_stones:
		stone memo.Set resulting_stones
		# known_stones â†© known_stonesâˆ¾stone
	}


	Incr â† {ğ•©} #{ğ•Šstone: iters â†© itersâˆ¾stone}
	Next â† {
		ğ•Šstone: memo.Has stone ? { memo.Get stone };

		0: Incr 0â‹„0âŠ¸SaveâŠ¸âŠ¢âŸ¨1âŸ©;

		ğ•Šstone: 0=2âŠ¸|â‰  repr â† â€¢Repr stone ? {
			!âŸ¨âŸ©â‰¡â‰¢stone
			Incr stone
			len â† Ã·âŸœ2â‰   repr
			stoneâŠ¸SaveâŠ¸âŠ¢ len(â†‘â‹ˆâ—‹â€¢ParseFloatâ†“)repr
		};

		ğ•Šstone: Incr stoneâ‹„stoneâŠ¸SaveâŠ¸âŠ¢âŸ¨stone Ã— 2024âŸ©
	}


	stones â†  â€¢ParseFloatÂ¨ (' 'âŠ¸â‰ )âŠ¸/Â¨ (+`' 'âŠ¸=)âŠ¸âŠ” âŠ‘lines
	known_stones â† âŸ¨âŸ©

	NewIter â† {
		ğ•Špathsâ€¿âŸ¨âŸ©: {
			# â€¢Out 50/"E"
			# â€¢Show (<"EMPTY")
			< paths âˆ¾ <âŸ¨âŸ©
		};
		ğ•Špathsâ€¿stone: âŠ‘ stone âˆŠ known_stones ? {
			new_path â† â‹ˆstone

			new_paths â†(stoneâŠ¸âˆ¾ËœÂ¨ paths) âˆ¾ (<new_path)
			res â† < new_paths 
		};
		ğ•Špathsâ€¿stone: {
			# â€¢Out 50/"N"
			# "paths" RLog paths
			# "stone" RLog (stone)
			known_stones âˆ¾âŸœstone â†©

			new_path â† â‹ˆstone
			new_paths â†(stoneâŠ¸âˆ¾ËœÂ¨ paths) âˆ¾ (<new_path)
			new_stones â† Next stone
			res â† Unify âŸ¨<new_paths, new_stonesâŸ©
			# "res " RLog res
			# res: [Path[], Stone]
		};
		ğ•Šarg: {
			arg
		};
		ğ•Šarg: {
			â€¢Show "no match"
			â€¢Show arg
			"Pattern matching failed" !0
		}
	}

	Unify â† {ğ•Špathsâ€¿new_stones:
		# â€¢Show paths
		# â€¢Show new_stones
		res â† (paths) âˆ¾âŒœ new_stones
		# "unify"âŠ¸RLogÂ¨ res
	}
	â€¢ShowÂ¨  (âˆ¾ âˆ˜(NewIterÂ¨))âŸ2 âŸ¨âŸ©âŠ¸â‹ˆÂ¨0â€¿0â€¿1


	# â€¢Show stones
	unique_stones â† â· { res â† âˆ¾ NextÂ¨ ğ•© â‹„ â€¢Showâˆ˜â€¢Show (â‰ â·res)â€¿(â‰ res)â‹„ res}âŸ50 stones
	FuncTwo â† { ğ•Šis:
		paths â† âŸ¨â‹ˆisâŸ©

		Func â† {ğ•Šstone:
			res â† âˆ¾ NextÂ¨ stone
			paths â†© pathsâˆ¾ (<(res))
			res
		}
		FuncâŸ25 â‹ˆis
		paths
	}

	all_stones â† â· stones âˆ¾ unique_stones
	unique_paths â† FuncTwoÂ¨ all_stones
	FindPath â† {ğ•Šstone:
		res â† (/Â·stoneâŠ¸= âŠ‘âˆ˜âŠ‘Â¨)âŠ¸âŠunique_paths
	}

	â€¢Out 50/"-"
	# "values" Rlog âˆ§â· ls
	# "counts" Rlog â‰ Â¨ (0â‰ â‰ Â¨)âŠ¸/ âŠ” ls

	New â† (((âŠ‘Â¨Â·âŠ”âŠ)âŠ¸âŠ) â‹ˆÂ¨ (â‰ Â¨Â·âŠ”âŠ))
	ToMap â† â‰Â·  >Â· New Â· âˆ¾((Â¯1âŠ‘âŠ‘)âˆ˜FindPath)Â¨
	Find â† {kğ•Šmap: (/k=âŠ)âŠ¸âŠ‘âŸœ(1âŠ¸âŠ) map}âŠ[âŸ¨âŸ©,âŸ¨âŸ©]
	# â€¢Show âŠ”âŠ âˆ¾((Â¯1âŠ‘âŠ‘)âˆ˜FindPath)Â¨ â‹ˆ125
	# â€¢Exit 0
	maps â† â‰ > â‹ˆâŸœToMapÂ¨ all_stones
	paired â† (âŠ‘stones) Find  maps
	# paired â† (17) Find  maps

	# â€¢Show 20 Find paired

	all_vals â† all_stones ({keyğ•Šm: sumâ† +Â´âˆ˜(1âŠ¸âŠ) key Find mâ‹„ keyâ€¿sum}Â¨)  <maps
	# "all_vals" RLog  all_vals
	keys â† 0âŠpaired
	# "keys" RLog keys
	# vals â† keys ({keyğ•Šm: sumâ† (1âŠ¸âŠ) key Find mâ‹„ keyâ€¿sum}Â¨)  <maps
	memo2 â† âŸ¨0âŸ© â€¢Hashmap âŸ¨âŸ¨1âŸ©âŸ©

	Save2 â† {stoneğ•Šresulting_stones:
		stone memo2.Set resulting_stones
		# known_stones â†© known_stonesâˆ¾stone
	}

	i â† 0
	Iter â† {
			stepsğ•Šstone: steps â‰¤ 75 ?
					i 1âŠ¸+â†©

					(0âŠ¸=100âŠ¸|)â—¶âŠ¢â€¿â€¢Show
					res â† stone Find  maps
					first_keys â†  âŠ res
					first_mults â† 1âŠ res
					# get first children
					# "first_keys" RLog first_keys

					# get 1st children of 1st children
					# second_children â† first_keys FindÂ¨  <maps
					# "second_children" RLog second_children
					# "2nd shape" RLog (â‰¢) second_children

					first_vals â† (steps+25)âŠ¸IterÂ¨ first_keys

					+Â´ first_mults Ã— first_vals

			; ğ•¨ğ•Šstone: memo2.Has stone ? {
				memo2.Get stone
			}

			; stepsğ•Šstone: {
				res â† stone Find  maps
				first_keys â†  âŠ res
				first_mults â† 1âŠ res
				stoneâŠ¸SaveâŸœâŠ¢  r â† +Â´ first_mults
				r
			}
	}
	# "multipliers" RLog multipliers â† ((0âŠ¸(âŠË˜))) paired
	# â€¢Show â· stonesâˆ¾unique_stones

	res â† +Â´ 0 IterÂ¨ stones



	â€¢Out "done"
	res

	# ls â† âˆ¾((Â¯1âŠ‘âŠ‘)âˆ˜FindPath)Â¨ â‹ˆ125
	# rs â† âˆ¾((Â¯1âŠ‘âŠ‘)âˆ˜FindPath)Â¨ â‹ˆ17
	# ls +â—‹â‰  rs
}

SolutionValidator â† {partâ€¿expectedğ•Šanswer:

	max_length â† expected âŒˆâ—‹(â‰ â€¢Fmt)  answer
	err_msg â† ("
Part "âˆ¾(â€¢Fmt part)âˆ¾" is wrong!"âˆ¾"
Expected: "âˆ¾({Â»âŸ(max_lengthâŠ¸-â‰ ğ•©) max_lengthâŠ¸â†‘ğ•©} â€¢Fmt expected)âˆ¾"
  Actual: "âˆ¾({Â»âŸ(max_lengthâŠ¸-â‰ ğ•©) max_lengthâŠ¸â†‘ğ•©} â€¢Fmt answer))âˆ¾"
"
	err_msg!(expected= answer)
	â€¢Show "Correctly solved Part "âˆ¾(â€¢Fmt part)âˆ¾": "âˆ¾(â€¢Fmt answer)
}

AtLeastPartialSolutionValidator â† {partâ€¿expectedğ•Šanswer:
	err_msg â† ("Part "âˆ¾(â€¢Fmt part)âˆ¾" is too low! Got instead: "âˆ¾(â€¢Fmt answer))
	err_msg!(expected< answer)
	â€¢Show "Correctly solved Part "âˆ¾(â€¢Fmt part)âˆ¾": "âˆ¾(â€¢Fmt answer)
}

AtMostPartialSolutionValidator â† {partâ€¿expectedğ•Šanswer:
	err_msg â† ("Part "âˆ¾(â€¢Fmt part)âˆ¾" is too high! Got instead: "âˆ¾(â€¢Fmt answer))
	err_msg!(expected> answer)
	â€¢Show "Correctly solved Part "âˆ¾(â€¢Fmt part)âˆ¾": "âˆ¾(â€¢Fmt answer)
}


# "part 1: " Log PartOne data
# "part 2: " Log PartTwo  data

# sample
# 1â€¿55312 SolutionValidator PartOne data
# input
# 1â€¿194482 SolutionValidator PartOne data


# sample
# 2â€¿??? SolutionValidator PartTwo data
# 2â€¿55312 SolutionValidator PartTwo data
2â€¿55312 SolutionValidator PartTwoAlt data

# 2â€¿(232454128072351) AtLeastPartialSolutionValidator PartTwoAlt data

# â€¢Show âˆ¾Â¨ â¥Š ((< 10+â†•5)â€¿(< 100+â†•5))âˆ¾âŒœ "ab"


# Next â† Ã—âŸœ2024

# â€¢Show Unify âŸ¨âŸ¨âŸ¨1âŸ©âŸ©,20â€¿24âŸ©
# â€¢Show (<â†•3) âˆ¾(<â†•3) âˆ¾ <â†•3

# input
# 2â€¿??? SolutionValidator PartTwo data

memo â† âŸ¨âŸ© â€¢Hashmap âŸ¨âŸ©
Save â† {stoneğ•Šresulting_stones:
	stone memo.Set resulting_stones
# known_stones â†© known_stonesâˆ¾stone
}
NextStone â† {
	ğ•Šstone: memo.Has stone ? { memo.Get stone };

	0: 0âŠ¸SaveâŠ¸âŠ¢âŸ¨1âŸ©;

	ğ•Šstone: 0=2âŠ¸|â‰  repr â† â€¢Repr stone ? {
		!âŸ¨âŸ©â‰¡â‰¢stone
		len â† Ã·âŸœ2â‰   repr
		stoneâŠ¸SaveâŠ¸âŠ¢ len(â†‘â‹ˆâ—‹â€¢ParseFloatâ†“)repr
	};

	ğ•Šstone: stoneâŠ¸SaveâŠ¸âŠ¢âŸ¨stone Ã— 2024âŸ©
}

Next â† {steps_leftğ•Šstone:
	{
		steps_left -â†© (stone â‰¤  4)
		steps_left -â†© 2Ã—(stone >  4)
		steps_left â‰¤0 ? âŸ¨1âŸ© ;
		stone = 0 ? âŸ¨1âŸ© ;
		{
		 new_stones â†	âˆ¾Â´ â¥Š NextStoneÂ¨ ğ•©
		 â€¢Show â‰  new_stones
		 new_stones}âŸ(3âŒŠsteps_left) stone
	}
}


# â€¢Show 3 Next 1
# â€¢Show NextStone 1
AddXToY â† {xğ•Šy: x + y}

# {{â€¢Out (â€¢Fmt â‰ )âŠ¸(âˆ¾âŸœ" "âŠ¸âˆ¾)âŸœ(80âŠ¸â†‘â€¢Fmt)}âŠ¸âŠ¢  âˆ¾NextStoneÂ¨ ğ•©}âŸ40 â‰1004
"starting" Rlog first_stone â† 368
known_stones â† âŸ¨first_stoneâŸ©
known_paths â† âŸ¨first_stoneâ€¿âŸ¨âŸ©âŸ©

pwrs â† 2âŠ¸â‹† 1+â†•20
# "stones" Rlog stones â† âŸ¨131, 22, 1000, 10120âŸ©
# "are pwr2" Rlog âŠâŸœstones / âˆŠâŸœpwrs â‰ âˆ˜â€¢ReprÂ¨ (stones)
# "are not pwr2" Rlog âŠâŸœstones / Â¬ âˆŠâŸœpwrs â‰ âˆ˜â€¢ReprÂ¨ (stones)

i â† 0
# stones â† âŸ¨0,27,5409930, 828979, 4471, 3, 68524, 170  âŸ©
stones â† âŸ¨2âŸ©
total_steps â† 5

# 30 ScoreDigits 1
# 4 + 4 + 4 + 4 + 4...
ScoreDigits â† {
	current_stepğ•Š1:
		# TODO handle less than 4 steps
		#...

		# else:
		4
}

ds â† âŸ¨âŸ© #degrading_stones
sd â† âŸ¨âŸ© #single digits
AddAndPrune â† {current_stepğ•Šstone:
	new_stones â† NextStone stone
	# unk_stones â† (new_stones (Â¬âˆ˜âˆŠ (â·âˆ˜/) âŠ£) known_stones)
	# known_stones âˆ¾â†© unk_stones
	# "i"Rlog i
	ds â†© ds âˆ¾â‹ˆ current_stepâ‹ˆ(	âŠâŸœnew_stones / âˆŠâŸœpwrs â‰ âˆ˜â€¢ReprÂ¨ (new_stones))
	# sd â†©  "valid" Rlog (<âŸœ10)âŠ¸/ new_stones
	# gt9 â† "gt 9" Rlog  (>âŸœ9)âŠ¸/ new_stones
	# "unk" RLog unk_stones
	# unk_stones
  âŠâŸœnew_stones / Â¬ âˆŠâŸœpwrs â‰ âˆ˜â€¢ReprÂ¨ (new_stones)
	new_stones
}

res â† {
	iâ†©0
	â€¢Show {
		i 1âŠ¸+â†©
		â€¢Show { (â‰ ğ•©)â€¿(ğ•©)}âŠ¸âŠ¢  âˆ¾  (iâŠ¸AddAndPrune)Â¨ ğ•© }âŸtotal_steps ğ•©
}Â¨ stones
"res" RLog res
# "known stones" RLog â‰  known_stones

"ds1"Rlog >ds
# "ds"âŠ¸RlogÂ¨ âˆ¾1âŠ‘Â¨Â¨ âŠ‘Â¨âŠ¸âŠ” ds

# 12340131
# 1234 131
# 12 34 265144
# 1 2 3 4 265 144
# x x x x 536360 291456
# x x x x 536 360 291 456
# x x x x 1084864 728640 588984 922944
# x x x x 2195764736 728 640 588 984 922 944
# x x x x 2195764736 1473472 1295360 1190112 1991616 1866128 1910656




# â€¢Show "Start"
# steps â† 35
# stone â† 9
# "result" Rlog â‰  resâ† steps Next stone
â€¢Show "done"

# â€¢Show table â† >2024âŠ¸Ã—âŠ¸(â‹ˆËœ)Â¨ â†•10
# # â€¢Show > (â†•10) â‹ˆÂ¨ (1âŠ‘Ë˜ table) Ã— 1âŒˆ(1Ã—2024âŠ¸Ã—âŸâŠ¢)Â¨ â‰¥âŸœ5âŠ‘Ë˜ table
# â€¢Show adj_table â† {Ã—âŸœ2024âŒ¾(1âŠ¸âŠË˜âˆ˜((â‰¥âŸœ5  âŠ‘Ë˜ğ•©)âŠ¸/))ğ•©}  table
# â€¢Show {â€¢Show ğ•¨-ğ•©â‹„ğ•©}`â€¢ParseFloatâˆ˜â†‘Â´Ë˜ >{ 2Ã·Ëœâ‰ Â¨ }âŠ¸â‹ˆË˜ â€¢ReprÂ¨ (4â†“  1âŠ¸âŠ‘Ë˜) adj_table


