data â† â€¢file.Lines "../../samples/2024/day11.txt"
# data â†© â€¢file.Lines "../../samples/2024/day11_alt.txt"
# data â†© â€¢file.Lines "../../inputs/2024/day11.txt"



# dyadic show but returns paired args
DShow â† {â€¢Show ğ•¨â€¿ğ•©â‹„ ğ•©}

Log â† {msgğ•Šval:
	â€¢Show (<msg)âˆ¾val
	val
}
RLog â† {msgğ•Šval:
	â€¢Show (msg)â‹ˆval
	val
}

iters â† âŸ¨âŸ©
PartOne â† {ğ•Šlines:
	Incr â† {ğ•©} #{ğ•Šstone: iters â†© itersâˆ¾stone}
	Next â† {
		0: Incr 0â‹„âŸ¨1âŸ©;
		ğ•Šstone: 0=2âŠ¸|â‰ â€¢Repr stone ?
			Incr stone
			len â† Ã·âŸœ2â‰   repr â† â€¢Repr  stone
			(â€¢ParseFloat lenâ†‘repr)â€¿(â€¢ParseFloat lenâ†“repr)
		;
		ğ•Šstone: Incr stoneâ‹„âŸ¨stone Ã— 2024âŸ©
	}

	stones â†  â€¢ParseFloatÂ¨ ((' 'âŠ¸â‰ ))âŠ¸/Â¨ (+`' 'âŠ¸=)âŠ¸âŠ” âŠ‘lines
	res â† â‰  (âˆ¾ NextÂ¨)âŸ25 stones
	"iters" Log (â‰ iters)â€¿(â‰ â·iters)

	res

}

PartTwo â† {ğ•Šlines:
	memo â† âŸ¨0âŸ© â€¢Hashmap âŸ¨âŸ¨1âŸ©âŸ©
	known_stones â† âŸ¨âŸ©

	# lines â†© â‹ˆ"125 17"

	Save â† {stoneğ•Šresulting_stones:
		stone memo.Set resulting_stones
		known_stones â†© known_stonesâˆ¾stone
	}

	Next â† {
		ğ•Šstone: memo.Has stone ? {
			memo.Get stone
		};
		ğ•Šstone: 0=2âŠ¸|â‰  reprâ†â€¢Repr stone ? {
			len â† Ã·âŸœ2â‰   repr
			!âŸ¨âŸ©â‰¡â‰¢stone

			stoneâŠ¸SaveâŠ¸âŠ¢ (lenâŠ¸â†‘â€¢ParseFloatÂ¨âˆ˜â‹ˆlenâŠ¸â†“) repr
		};
		ğ•Šstone: {
			stoneâŠ¸SaveâŠ¸âŠ¢ âŸ¨stone Ã— 2024âŸ©
		}
	}


	#      âŒœ-------------------------------------âŒ
	# 0 -> 1 -> 2024 -> 20 24 -> 2 0 2 4 -> 4028 1 4028 8096
	# 0 -> 1 -> 2024 -> 20 -> 2 -> 4028 -> 40 -> 4
	#                                         -> 0
	#                                      28 -> 2
	#                                         -> 8 -> 16192 -> 32772608 -> 3277 -> 32 -> 2
	#                                                                                 -> 3 -> 6072 -> 60
	#                                                                                              -> 72
	#                                                                           -> 77 -> 7
	#                                                                                 -> 7
	#                                                                   -> 2608
	#											    0 -> 1
	#										24 -> 2 -> 4028
	#                         4 -> 8096

	start â† â€¢Monotime @

	stones â†  â€¢ParseFloatÂ¨ ((' 'âŠ¸â‰ ))âŠ¸/Â¨ (+`' 'âŠ¸=)âŠ¸âŠ” âŠ‘lines

	known_paths â† âŸ¨âŸ©
	BuildKnownPaths â† {
		firsts â† âŠ‘Â¨ğ•©
		is_old â† firstsâˆŠknown_stones
		old_paths â† is_old/ğ•©
		known_paths â†© old_pathsâˆ¾known_paths

		not_oldâ† (Â¬is_old)/ğ•©
		âˆ¾((NextË˜âˆ˜âŠ‘)âˆ¾Â¨<)Â¨  not_old
	}

	# "stones" RLog stones
	iterations â† 25
	unfinished â† BuildKnownPathsâŸ25 "stones" RLog â‹ˆÂ¨stones
	"known_paths"âŠ¸RLogÂ¨ known_paths
	# "unfinished"âŠ¸Rlog â‰ unfinished

	FindPathsContaining â† {ğ•Šmax_rangeâ€¿old_path: max_range > 0? {

			stone â† âŠ‘old_path
			FindRange â† {ğ•Špath:
				leftmostâ€¿range â† (âŠ‘â‹ˆ(Â¯1âŠ¸âŠ‘Â·/stoneâŠ¸=))path
			}
			AdjRange â† {ğ•Šnew_path:
				leftmostâ€¿range â† FindRange new_path
				diff â† max_rangeâŒŠrange
				new_range â† (max_range-diff)

				new_rangeâ€¿((diffâ†‘new_path)âˆ¾(old_path))
			}

			res â† AdjRangeÂ¨ ((0âŠ¸â‰ â‰ )Â·/Â·stoneâŠ¸=Ëœ1âŠ¸â†“)Â¨âŠ¸/ known_paths
			res

		}; ğ•Šmax_rangeâ€¿stone: âŸ¨max_rangeâ€¿stoneâŸ©
	}

	# â€¢Show table â† âŒ½Ë˜ 14â†‘ > (âŒˆÂ´â‰ Â¨)âŠ¸(â†‘Â¨)known_paths
	# â€¢Show {
	# 	n â†ğ•¨â‰ ğ•©
	# 	â€¢Show nÃ—ğ•©
	# 	ğ•¨
	# }Ë table

	# â€¢Show maxes â† â‰ âˆ˜â€¢FmtÂ¨ ( âŒˆ)Ë table
		# max_length { Â»âŸ(ğ•¨âŠ¸-â‰ ğ•©) ğ•¨âŠ¸â†‘ğ•©} maxes

	# â€¢Exit 0

	â€¢Out ""
	paired_stones â† â€¢Show iterationsâŠ¸(â‹ˆâŸœâ‹ˆÂ¨)stones
  "len"âŠ¸Log â‰  {(â€¢Showâˆ˜â‰ âŠ¸âŠ¢)âˆ˜âˆ¾FindPathsContainingÂ¨}âŸ5 paired_stones #âŸ¨25â€¿âŸ¨125âŸ©âŸ©
	â€¢Out ""

	123


	# â€¢Exit 0
	# iterations â† "iterations" Log 1
	# res â†  (âˆ¾ NextÂ¨)âŸiterations stones
	# "iters" Log (â‰ iters)â€¿(â‰ â·iters)
	# end â† â€¢Monotime @
	# "elapsed" Log end-start
  #
	# "res"Log res
	# â‰ res
}

PartTwoAlt â† {ğ•Šlines:
	memo â† âŸ¨0âŸ© â€¢Hashmap âŸ¨âŸ¨1âŸ©âŸ©

	Save â† {stoneğ•Šresulting_stones:
		stone memo.Set resulting_stones
		# known_stones â†© known_stonesâˆ¾stone
	}


	Incr â† {ğ•©} #{ğ•Šstone: iters â†© itersâˆ¾stone}
	Next â† {
		ğ•Šstone: memo.Has stone ? {
			memo.Get stone
		};
		0: Incr 0â‹„0âŠ¸SaveâŠ¸âŠ¢âŸ¨1âŸ©;
		ğ•Šstone: 0=2âŠ¸|â‰ â€¢Repr stone ?

			# "stone" Rlog stone
			!âŸ¨âŸ©â‰¡â‰¢stone
			Incr stone
			len â† Ã·âŸœ2â‰   repr â† â€¢Repr  stone
			stoneâŠ¸SaveâŠ¸âŠ¢(â€¢ParseFloat lenâ†‘repr)â€¿(â€¢ParseFloat lenâ†“repr)
		;
		ğ•Šstone: Incr stoneâ‹„stoneâŠ¸SaveâŠ¸âŠ¢âŸ¨stone Ã— 2024âŸ©
	}


	stones â†  â€¢ParseFloatÂ¨ ((' 'âŠ¸â‰ ))âŠ¸/Â¨ (+`' 'âŠ¸=)âŠ¸âŠ” âŠ‘lines
	unique_stones â† â· res â† (âˆ¾ NextÂ¨)âŸ25 stones



	FuncTwo â† { ğ•Šis:
		paths â† âŸ¨â‹ˆisâŸ©

		Func â† {ğ•Šstone:
			res â† âˆ¾ NextÂ¨ stone
			paths â†© pathsâˆ¾ (<(res))
			res
		}
		FuncâŸ25 â‹ˆis
		paths
	}

	unique_paths â† FuncTwoÂ¨ stonesâˆ¾unique_stones
	FindPath â† {ğ•Šstone:
		res â† (/Â·stoneâŠ¸= âŠ‘âˆ˜âŠ‘Â¨)âŠ¸âŠunique_paths
	}

	â€¢Out 50/"-"
	# "values" Rlog âˆ§â· ls
	# "counts" Rlog â‰ Â¨ (0â‰ â‰ Â¨)âŠ¸/ âŠ” ls

	New â† (((âŠ‘Â¨Â·âŠ”âŠ)âŠ¸âŠ) â‹ˆÂ¨ (â‰ Â¨Â·âŠ”âŠ))
	ToMap â† â‰Â·  >Â· New Â· âˆ¾((Â¯1âŠ‘âŠ‘)âˆ˜FindPath)Â¨
	Find â† {kğ•Šmap: (/k=âŠ)âŠ¸âŠ‘âŸœ(1âŠ¸âŠ) map}
	# â€¢Show âŠ”âŠ âˆ¾((Â¯1âŠ‘âŠ‘)âˆ˜FindPath)Â¨ â‹ˆ125
	# â€¢Exit 0
	maps â† â‹ˆâŸœToMapÂ¨ unique_stones

	# "paired"âŠ¸Rlog  paired
	paired â† ToMap â‹ˆ125
	â€¢Show 0 Find paired

	"keys" RLog âŠ paired



	res
	â€¢Out "done"

	ls â† âˆ¾((Â¯1âŠ‘âŠ‘)âˆ˜FindPath)Â¨ â‹ˆ125
	rs â† âˆ¾((Â¯1âŠ‘âŠ‘)âˆ˜FindPath)Â¨ â‹ˆ17
	ls +â—‹â‰  rs
}

SolutionValidator â† {partâ€¿expectedğ•Šanswer:

	max_length â† expected âŒˆâ—‹(â‰ â€¢Fmt)  answer
	err_msg â† ("
Part "âˆ¾(â€¢Fmt part)âˆ¾" is wrong!"âˆ¾"
Expected: "âˆ¾({Â»âŸ(max_lengthâŠ¸-â‰ ğ•©) max_lengthâŠ¸â†‘ğ•©} â€¢Fmt expected)âˆ¾"
  Actual: "âˆ¾({Â»âŸ(max_lengthâŠ¸-â‰ ğ•©) max_lengthâŠ¸â†‘ğ•©} â€¢Fmt answer))âˆ¾"
"
	err_msg!(expected= answer)
	â€¢Show "Correctly solved Part "âˆ¾(â€¢Fmt part)âˆ¾": "âˆ¾(â€¢Fmt answer)
}

AtLeastPartialSolutionValidator â† {partâ€¿expectedğ•Šanswer:
	err_msg â† ("Part "âˆ¾(â€¢Fmt part)âˆ¾" is too low! Got instead: "âˆ¾(â€¢Fmt answer))
	err_msg!(expectedâ‰¥ answer)
	â€¢Show "Correctly solved Part "âˆ¾(â€¢Fmt part)âˆ¾": "âˆ¾(â€¢Fmt answer)
}

AtMostPartialSolutionValidator â† {partâ€¿expectedğ•Šanswer:
	err_msg â† ("Part "âˆ¾(â€¢Fmt part)âˆ¾" is too high! Got instead: "âˆ¾(â€¢Fmt answer))
	err_msg!(expected< answer)
	â€¢Show "Correctly solved Part "âˆ¾(â€¢Fmt part)âˆ¾": "âˆ¾(â€¢Fmt answer)
}


# "part 1: " Log PartOne data
# "part 2: " Log PartTwo  data

# sample
# 1â€¿55312 SolutionValidator PartOne data
# input
# 1â€¿194482 SolutionValidator PartOne data


# sample
# 2â€¿??? SolutionValidator PartTwo data
# 2â€¿55312 SolutionValidator PartTwo data
2â€¿55312 SolutionValidator PartTwoAlt data

# â€¢Show âŠ”âŠ âˆ§10â€¿2â€¿2â€¿3â€¿5â€¿9
# â€¢Show (âŠ‘Â¨Â·âŠ”âŠ)âŠ¸âŠ âˆ§10â€¿2â€¿2â€¿3â€¿5â€¿9
# â€¢Show (â‰ Â¨Â·âŠ”âŠ) âˆ§10â€¿2â€¿2â€¿3â€¿5â€¿9
# â€¢Show (((âŠ‘Â¨Â·âŠ”âŠ)âŠ¸âŠ) â‹ˆÂ¨ (â‰ Â¨Â·âŠ”âŠ)) âˆ§10â€¿2â€¿2â€¿3â€¿5â€¿9
# â€¢Show ((âˆ§â·)â‹ˆÂ¨(â‰ Â¨Â· (0â‰ â‰ Â¨)âŠ¸/ âŠ”))10â€¿2â€¿2â€¿3â€¿5â€¿9
#
# input
# 2â€¿??? SolutionValidator PartTwo data
