data â† â€¢file.Lines "../../samples/2024/day11.txt"
# data â†© â€¢file.Lines "../../samples/2024/day11_alt.txt"
data â†© â€¢file.Lines "../../inputs/2024/day11.txt"



# dyadic show but returns paired args
DShow â† {â€¢Show ğ•¨â€¿ğ•©â‹„ ğ•©}

Log â† {msgğ•Šval:
	â€¢Show (<msg)âˆ¾val
	val
}
RLog â† {msgğ•Šval:
	â€¢Show (msg)â‹ˆval
	val
}

iters â† âŸ¨âŸ©
PartOne â† {ğ•Šlines:
	Incr â† {ğ•©} #{ğ•Šstone: iters â†© itersâˆ¾stone}
	Next â† {
		0: Incr 0â‹„âŸ¨1âŸ©;
		ğ•Šstone: 0=2âŠ¸|â‰ â€¢Repr stone ?
			Incr stone
			len â† Ã·âŸœ2â‰   repr â† â€¢Repr  stone
			(â€¢ParseFloat lenâ†‘repr)â€¿(â€¢ParseFloat lenâ†“repr)
		;
		ğ•Šstone: Incr stoneâ‹„âŸ¨stone Ã— 2024âŸ©
	}

	stones â†  â€¢ParseFloatÂ¨ ((' 'âŠ¸â‰ ))âŠ¸/Â¨ (+`' 'âŠ¸=)âŠ¸âŠ” âŠ‘lines
	res â† â‰  (âˆ¾ NextÂ¨)âŸ25 stones
	"iters" Log (â‰ iters)â€¿(â‰ â·iters)

	res

}

PartTwoAlt â† {ğ•Šlines:
	memo â† âŸ¨0âŸ© â€¢Hashmap âŸ¨âŸ¨1âŸ©âŸ©

	Save â† {stoneğ•Šresulting_stones:
		stone memo.Set resulting_stones
		# known_stones â†© known_stonesâˆ¾stone
	}


	Incr â† {ğ•©} #{ğ•Šstone: iters â†© itersâˆ¾stone}
	Next â† {
		ğ•Šstone: memo.Has stone ? {
			memo.Get stone
		};
		0: Incr 0â‹„0âŠ¸SaveâŠ¸âŠ¢âŸ¨1âŸ©;
		ğ•Šstone: 0=2âŠ¸|â‰ â€¢Repr stone ?

			# "stone" Rlog stone
			!âŸ¨âŸ©â‰¡â‰¢stone
			Incr stone
			len â† Ã·âŸœ2â‰   repr â† â€¢Repr  stone
			stoneâŠ¸SaveâŠ¸âŠ¢(â€¢ParseFloat lenâ†‘repr)â€¿(â€¢ParseFloat lenâ†“repr)
		;
		ğ•Šstone: Incr stoneâ‹„stoneâŠ¸SaveâŠ¸âŠ¢âŸ¨stone Ã— 2024âŸ©
	}


	stones â†  â€¢ParseFloatÂ¨ ((' 'âŠ¸â‰ ))âŠ¸/Â¨ (+`' 'âŠ¸=)âŠ¸âŠ” âŠ‘lines
	# â€¢Show stones
	unique_stones â† â· (âˆ¾ NextÂ¨)âŸ25 stones



	FuncTwo â† { ğ•Šis:
		paths â† âŸ¨â‹ˆisâŸ©

		Func â† {ğ•Šstone:
			res â† âˆ¾ NextÂ¨ stone
			paths â†© pathsâˆ¾ (<(res))
			res
		}
		FuncâŸ25 â‹ˆis
		paths
	}

	all_stones â† â· stones âˆ¾ unique_stones
	unique_paths â† FuncTwoÂ¨ all_stones
	FindPath â† {ğ•Šstone:
		res â† (/Â·stoneâŠ¸= âŠ‘âˆ˜âŠ‘Â¨)âŠ¸âŠunique_paths
	}

	â€¢Out 50/"-"
	# "values" Rlog âˆ§â· ls
	# "counts" Rlog â‰ Â¨ (0â‰ â‰ Â¨)âŠ¸/ âŠ” ls

	New â† (((âŠ‘Â¨Â·âŠ”âŠ)âŠ¸âŠ) â‹ˆÂ¨ (â‰ Â¨Â·âŠ”âŠ))
	ToMap â† â‰Â·  >Â· New Â· âˆ¾((Â¯1âŠ‘âŠ‘)âˆ˜FindPath)Â¨
	Find â† {kğ•Šmap: (/k=âŠ)âŠ¸âŠ‘âŸœ(1âŠ¸âŠ) map}âŠ[âŸ¨âŸ©,âŸ¨âŸ©]
	# â€¢Show âŠ”âŠ âˆ¾((Â¯1âŠ‘âŠ‘)âˆ˜FindPath)Â¨ â‹ˆ125
	# â€¢Exit 0
	maps â† â‰ > â‹ˆâŸœToMapÂ¨ all_stones
	paired â† (âŠ‘stones) Find  maps
	# paired â† (17) Find  maps

	# â€¢Show 20 Find paired

	all_vals â† all_stones ({keyğ•Šm: sumâ† +Â´âˆ˜(1âŠ¸âŠ) key Find mâ‹„ keyâ€¿sum}Â¨)  <maps
	# "all_vals" RLog  all_vals
	keys â† 0âŠpaired
	# "keys" RLog keys
	# vals â† keys ({keyğ•Šm: sumâ† (1âŠ¸âŠ) key Find mâ‹„ keyâ€¿sum}Â¨)  <maps
	memo2 â† âŸ¨0âŸ© â€¢Hashmap âŸ¨âŸ¨1âŸ©âŸ©

	Save2 â† {stoneğ•Šresulting_stones:
		stone memo2.Set resulting_stones
		# known_stones â†© known_stonesâˆ¾stone
	}

	Iter â† {
	stepsğ•Šstone: steps â‰¤ 75 ?
			res â† stone Find  maps
			first_keys â†  âŠ res
			first_mults â† 1âŠ res
			# get first children
			# "first_keys" RLog first_keys

			# get 1st children of 1st children
			# second_children â† first_keys FindÂ¨  <maps
			# "second_children" RLog second_children
			# "2nd shape" RLog (â‰¢) second_children

			first_vals â† (steps+25)âŠ¸IterÂ¨ first_keys

			+Â´ first_mults Ã— first_vals
		; ğ•¨ğ•Šstone: memo2.Has stone ? {
			memo2.Get stone
		}

			; stepsğ•Šstone:


			â€¢Show stone
  
			res â† stone Find  maps
			first_keys â†  âŠ res
			first_mults â† 1âŠ res
			stoneâŠ¸SaveâŸœâŠ¢ +Â´ first_mults
	}
	# "multipliers" RLog multipliers â† ((0âŠ¸(âŠË˜))) paired
	# â€¢Show â· stonesâˆ¾unique_stones

	res â† +Â´ 0 IterÂ¨ stones



# # 0  flips
# 1 -> 3 3
#
# # 1	flips
# 3 -> 5 5 2 2
# 3 -> 5 5 2 2
#
# # 2 flips
# 5 -> 7 7
# 5 -> 7 7
# 2 -> 4 4
# 2 -> 4 4


qwe â† "
1    3        6    5    2
2 2  4 4 1    7    6 6  3
3 3  5 5 2 2  8 8  7 7  4 4
"

	# 125 maps to 0,1,2
	#             5,6,7

	# 0 maps to   2,3,4
	#						  7,8,9

	# 2 maps to   4,5,6
	#						  9,2,1


	â€¢Out "done"
	res

	# ls â† âˆ¾((Â¯1âŠ‘âŠ‘)âˆ˜FindPath)Â¨ â‹ˆ125
	# rs â† âˆ¾((Â¯1âŠ‘âŠ‘)âˆ˜FindPath)Â¨ â‹ˆ17
	# ls +â—‹â‰  rs
}

SolutionValidator â† {partâ€¿expectedğ•Šanswer:

	max_length â† expected âŒˆâ—‹(â‰ â€¢Fmt)  answer
	err_msg â† ("
Part "âˆ¾(â€¢Fmt part)âˆ¾" is wrong!"âˆ¾"
Expected: "âˆ¾({Â»âŸ(max_lengthâŠ¸-â‰ ğ•©) max_lengthâŠ¸â†‘ğ•©} â€¢Fmt expected)âˆ¾"
  Actual: "âˆ¾({Â»âŸ(max_lengthâŠ¸-â‰ ğ•©) max_lengthâŠ¸â†‘ğ•©} â€¢Fmt answer))âˆ¾"
"
	err_msg!(expected= answer)
	â€¢Show "Correctly solved Part "âˆ¾(â€¢Fmt part)âˆ¾": "âˆ¾(â€¢Fmt answer)
}

AtLeastPartialSolutionValidator â† {partâ€¿expectedğ•Šanswer:
	err_msg â† ("Part "âˆ¾(â€¢Fmt part)âˆ¾" is too low! Got instead: "âˆ¾(â€¢Fmt answer))
	err_msg!(expected< answer)
	â€¢Show "Correctly solved Part "âˆ¾(â€¢Fmt part)âˆ¾": "âˆ¾(â€¢Fmt answer)
}

AtMostPartialSolutionValidator â† {partâ€¿expectedğ•Šanswer:
	err_msg â† ("Part "âˆ¾(â€¢Fmt part)âˆ¾" is too high! Got instead: "âˆ¾(â€¢Fmt answer))
	err_msg!(expected> answer)
	â€¢Show "Correctly solved Part "âˆ¾(â€¢Fmt part)âˆ¾": "âˆ¾(â€¢Fmt answer)
}


# "part 1: " Log PartOne data
# "part 2: " Log PartTwo  data

# sample
# 1â€¿55312 SolutionValidator PartOne data
# input
# 1â€¿194482 SolutionValidator PartOne data


# sample
# 2â€¿??? SolutionValidator PartTwo data
# 2â€¿55312 SolutionValidator PartTwo data
# 2â€¿55312 SolutionValidator PartTwoAlt data
2â€¿(232454128072351) AtLeastPartialSolutionValidator PartTwoAlt data

# â€¢Show âŠ”âŠ âˆ§10â€¿2â€¿2â€¿3â€¿5â€¿9
# â€¢Show (âŠ‘Â¨Â·âŠ”âŠ)âŠ¸âŠ âˆ§10â€¿2â€¿2â€¿3â€¿5â€¿9
# â€¢Show (â‰ Â¨Â·âŠ”âŠ) âˆ§10â€¿2â€¿2â€¿3â€¿5â€¿9
# â€¢Show (((âŠ‘Â¨Â·âŠ”âŠ)âŠ¸âŠ) â‹ˆÂ¨ (â‰ Â¨Â·âŠ”âŠ)) âˆ§10â€¿2â€¿2â€¿3â€¿5â€¿9
# â€¢Show ((âˆ§â·)â‹ˆÂ¨(â‰ Â¨Â· (0â‰ â‰ Â¨)âŠ¸/ âŠ”))10â€¿2â€¿2â€¿3â€¿5â€¿9
#
# input
# 2â€¿??? SolutionValidator PartTwo data
